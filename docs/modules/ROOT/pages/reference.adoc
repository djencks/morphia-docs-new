== Mapping

=== Classes

Mapping is achieved through one of two annotations to start:  {apiRef}/dev/morphia/annotations/Entity[@Entity] and
{apiRef}/dev/morphia/annotations/Embedded[@Embedded].  In order for Morphia to consider any type for mapping, it must have one
of these two annotation.  `@Entity` is used to denote a "top level" type.  These types tend to have their own collections whose names
can be mapped via the `value` parameter.  Leaving this value blank will leave Morphia free to compute the collection name as defined by
the collection naming strategy defined in {apiRef}/dev/morphia/mapping/MapperOptions[@MapperOptions].  That default is
currently the camel case value of the class's simple name.  For example, to map a `UserProfile` entity under this strategy, the
collection name would be mapped to `userProfile`.

Any type annotated with `@Entity` must have a field annotated with {apiRef}/dev/morphia/annotations/Id[@Id].  The type of the
field can be any type so long as Morphia or the driver have codecs that can map the data to and from mongodb.  When mapping an entity,
one can also define [indexes]({{< relref "indexing.md" >}}) and [schema validations]({{< relref "schemaValidation.md" >}}) as part of
the entity declaration as well.

==== Constructors
Morphia has traditionally required a 0-argument constructor on any mapped entity.  In fact, Morphia still prefers to use such a
constructor should one be available.  However, as of 2.1, Morphia can also make use of another constructor that meets certain criteria:

1. The number of arguments in the constructor must match the number of fields on the class.  That is, every field must be represented in
the constructor signature.
2. The names of the arguments must match the names of the fields.  Here, there is a bit of flexibility.  The argument name can match
either the field name as found in the source or the mapped name as determined by any `@Property` annotation.  While this is likely to be
the most common case as it is the simplest, for various this won't always be possible or preferable.  If a constructor argument name
can't mirror the field name, using the {apiRef}/dev/morphia/annotations/Name[@Name] annotation, an explict name can be given
so that the argument can be properly matched to a field.

[WARNING]
====
Changing the mapping configuration can interfere with Morphia's ability to map arguments and fields so be careful when making changes to
such things as the default field naming strategy or {apiRef}/dev/morphia/annotations/Property[`@Property`] definitions.
====

For this mapping to take place, the source must be compiled to include the parameters in the generated bytecode.  With `javac` this is
typically already configured by default.  However, Kotlin users will likely need to configure their builds to include the appropriate
option.  For maven users, it's as simple as adding one line to the Kotlin maven plugin `<configuration>`:

[source,xml]
----
    <javaParameters>true</javaParameters>
----

=== External types
Some times persisted types come from external libraries whose source is either unavailable or simply can't be modified.  Using these
types would be impossible give then annotation requirements as stated above.  Morphia 2.1 introduced a new experimental API that loosens
these restrictions a bit.  Using {apiRef}/dev/morphia/mapping/Mapper#mapExternal(A,java.lang.Class)[Mapper#mapExternal] these
external types can be passed in for use as embedded types in other entities.  An optional instance of `@Embedded` can created using the
{apiRef}/dev/morphia/annotations/experimental/EmbeddedBuilder[EmbeddedBuilder].  A null can be passed in to simply accept the
default values.

[NOTE]
====
This API is experimental and is likely to shift a bit as it sees usage and feedback from the community.
====

=== Versioning
Entities can be versioned to ensure that changes are applied serially and that no other processes are modifying an object in between the
time it's fetched, modified, and written back to the database.  To achieve this, simply add a field to a type, it can be a `long` or a
`Long`, and annotate that field with {apiRef}/dev/morphia/annotations/Version[@Version].  This field must not be initialized
to anything other than zero or null, however.  Morphia will take care of the rest.  If an object is fetched and another process
updates the corresponding document in the database before it can be persisted back, an exception will be thrown when the write is
attempted.

=== Fields

By default, any non-static field on a mapped class will be processed for persistence.  If a field is to be excluded from the mapping, it
can be decorated with the `transient` keyword, annotated with  {apiRef}/dev/morphia/annotations/Transient[@Transient], or with
the `java.beans.Transient` annotation.  Otherwise all fields will be included that are defined on the mapped class and any super type.
However, Morphia will ignore fields in any super types found in `java*` packages which includes the standard JDK classes and the Java EE
APIs.

There are times when it is necessary to modify a field mapping's name, e.g. Using the
{apiRef}/dev/morphia/annotations/Property[@Property] annotation, a new name can be defined that will be used when writing to
and reading from the database.  During a schema evolution, it is possible to load a field from an old name as well using the
{apiRef}/dev/morphia/annotations/AlsoLoad[@AlsoLoad] annotation.  Using this annotation, multiple old names can be used to
find a field's value in a returned document from query.  However, only the field's name or the value specified in the `@Property`
annotation will be used when writing documents back to the database.  Similarly, if data is only intended to be loaded from the database
but never written back, that field can be annotated with {apiRef}/dev/morphia/annotations/LoadOnly[@LoadOnly]

If you do not specify a name via `@Property`, the default field naming strategy will be used.  The default strategy is to use the field's
name as defined in the source.  This strategy can be changed globally via the field naming strategy option on
{apiRef}/dev/morphia/mapping/MapperOptions[@MapperOptions].  Simple indexes can be defined on a field if all that is needed for
the index is a single field.  This can be done via the {apiRef}/dev/morphia/annotations/Indexed[@Indexed] annotation.

== Queries

Morphia provides {apiRef}/dev/morphia/query/Query.html[`Query<T>`] class to build a query and map the results back to instances of your
entity classes and attempts to provide as much type safety and validation as possible.  To create the `Query`, we invoke the following code:

[source,java]
----
Query<Product> query = datastore.find(Product.class);
----

`find()` returns an instance of `Query` which we can use to build a query.

=== `filter()`

The most significant method `filter(Filter...)`.  This method takes a number of filters to apply to the query being built.  The
filters are added to any existing, previously defined filters so you needn't add them all at once.  There are dozens of filters
predefined in Morphia and can be found in the `dev.morphia.query.experimental.filters` package.

[NOTE]
====
The package is currently `experimental`.  This done to signify that this API is a new one and might change based on user feedback
prior to a final release.  It is expected that the API will be largely the same in the final release and you are highly encouraged
to try it out before then.  If you encounter and bugs or usability issues, please file an
https://github.com/MorphiaOrg/morphia/issues[issue]
====

The filters can be accessed via the {apiRef}/dev/morphia/query/experimental/filters/Filters[Filters] class.  The method names
largely match the operation name you would use querying via the mongo shell so this should help you translate queries in to Morphia's
API. For example, to query for products whose prices is greater than or equal to 1000, you would write this:

[source,java]
----
query.filter(Filters.gte("price", 1000));
----

This will append the new criteria to any existing criteria already defined.  You can define as many filters in one call as you'd like or
you may choose to append them in smaller groups based on whatever query building logic your application might have.

== Complex Queries

Of course, queries are usually more complex than single field comparisons.  Morphia offers both `and()` and `or()` to build up more
complex queries.  An `and` query might look something like this:

[source,java]
----
q.filter(and(
    eq("width", 10),
    eq("height", 1)));
----

An `or` clause looks exactly the same except for using `or()` instead of `and()`, of course.  The default is to "and" filter criteria
together so if all you need is an `and` clause, you don't need an explicit call to `and()`:

[source,java]
----
datastore.find(UserLocation.class)
    .filter(
        lt("x", 5),
        gt("y", 4),
        gt("z", 10));
----

This generates an implicit `and` across the field comparisons.

== Other Query Options

There is more to querying than simply filtering against different document values.  Listed below are some of the options for modifying
the query results in different ways.

=== Projections

{docsRef}/tutorial/project-fields-from-query-results/[Projections] allow you to return only a subset of the fields in a
document.  This is useful when you need to only return a smaller view of a larger object.  Borrowing from the
{srcRef}/morphia/src/test/java/dev/morphia/TestQuery.java[unit tests], this is an example of this feature in action:

[source,java]
----
ContainsRenamedFields user = new ContainsRenamedFields("Frank", "Zappa");
datastore.save(user);

ContainsRenamedFields found = datastore
                                  .find(ContainsRenamedFields.class)
                                  .iterator(new FindOptions()
                                               .projection().include("first_name")
                                               .limit(1))
                                  .tryNext();
assertNotNull(found.firstName);
assertNull(found.lastName);
----

As you can see here, we're saving this entity with a first and last name but our query only returns the first name (and the `_id` value) in
the returned instance of our type.  It's also worth noting that this project works with both the mapped document field name
`"first_name"` and the Java field name `"firstName"`.

[WARNING]
====
While projections can be a nice performance win in some cases, it's important to note that this object can not be safely saved back to
MongoDB. Any fields in the existing document in the database that are missing from the entity will be removed if this entity is
saved.  For example, in the example above if `found` is saved back to MongoDB, the `last_name` field that currently exists in the database
for this entity will be removed.  To save such instances back consider using {apiRef}/dev/morphia/Datastore#merge-T-[`Datastore#merge(T)`]
====

=== Limiting and Skipping

Pagination of query results is often done as a combination of skips and limits.  Morphia offers `FindOptions.limit(int)` and
`FindOptions.offset(int)` for these cases.  An example of these methods in action would look like this:

[source,java]
----
datastore.createQuery(Person.class)
    .iterator(new FindOptions()
	    .offset(1)
	    .limit(10))
----

This query will skip the first element and take up to the next 10 items found by the query.  There's a caveat to using skip/limit for
pagination, however.  See the {docsRef}/reference/method/cursor.skip[skip] documentation for more detail.

=== Ordering

Ordering the results of a query is done via {apiRef}dev/morphia/query/FindOptions.html#sort(dev.morphia.query.Sort...)[`FindOptions.sort(Sort...)`],
etc.  For example, to sort by `age` (youngest to oldest) and then `income` (highest to lowest), you would
use this:

[source,java]
----
getDs().find(User.class)
       .iterator(new FindOptions()
                    .sort(ascending("age"), descending("income"))
                    .limit(1))
       .tryNext();
----

=== Tailable Cursors

If you have a {docsRef}/core/capped-collections/[capped collection] it's possible to "tail" a query so that when new documents
are added to the collection that match your query, they'll be returned by the
{docsRef}/reference/glossary/#term-tailable-cursor[tailable cursor].  An example of this feature in action can be found in the
{srcRef}/morphia/src/test/java/dev/morphia/TestQuery.java[unit tests] in the `testTailableCursors()` test:

[source,java]
----
datastore.getMapper().map(CappedPic.class);
getDs().ensureCaps();                                                          // <1>
final Query<CappedPic> query = getDs().find(CappedPic.class);
final List<CappedPic> found = new ArrayList<>();

final MorphiaCursor<CappedPic> tail = query.iterator(new FindOptions()
                                                   .cursorType(CursorType.Tailable));
while(found.size() < 10) {
	found.add(tail.next());                                                    // <2>
}
----
There are two things to note about this code sample:

1. This tells Morphia to make sure that any entity [configured]({{< ref "/guides/annotations#entity" >}}) to use a capped
collection has its collection created correctly.  If the collection already exists and is not capped, you will have to manually
{docsRef}/core/capped-collections/#convert-a-collection-to-capped[update] your collection to be a capped collection.
2. Since this `Iterator` is backed by a tailable cursor, `hasNext()` and `next()` will block until a new item is found.  In this
version of the unit test, we tail the cursor waiting to pull out objects until we have 10 of them and then proceed with the rest of the
application.

== Updates

Updates in 2.0, are issued using a `Query` instance .  These update operations are executed on the server without fetching any documents
across the wire.  Update operations are defined using a set of functions as defined on
{apiRef}/dev/morphia/query/experimental/updates/UpdateOperators[UpdateOperators].  In our examples, we'll be using the following model:

[source,java]
----
@Entity("hotels")
public class Hotel
{
   @Id
   private ObjectId id;

   private String name;
   private int stars;

   @Embedded
   private Address address;

   List<Integer> roomNumbers = new ArrayList<Integer>();

   // ... getters and setters
}

@Embedded
public class Address
{
   private String street;
   private String city;
   private String postalCode;
   private String country;

   // ... getters and setters
}
----

=== set()/unset()
To change the name of the hotel, one would use something like this:

[source,java]
----
datastore
    .find(Hotel.class)
    .update(UpdateOperators.set("name", "Fairmont Chateau Laurier"))
    .execute();
----

The `execute()` can optionally take {apiRef}/dev/morphia/UpdateOptions[UpdateOptions] if there are any options you might want
to apply to your update statement.

Embedded documents are updated the same way.  To change the name of the city in the address, one would use something like this:

[source,java]
----
datastore
    .find(Hotel.class)
    .update(UpdateOperators.set("address.city", "Ottawa"))
    execute();
----

Values can also be removed from documents as shown below:

[source,java]
----
datastore
    .find(Hotel.class)
    .update(UpdateOperators.unset("name"))
    execute();
----

After this update, the name of the hotel would be `null` when the entity is loaded.

=== Multiple Updates

By default, an update operation will only update the first document matching the query.  This behavior can be modified via the optional
{apiRef}/dev/morphia/UpdateOptions[UpdateOptions] parameter on `execute()`:

[source,java]
----
datastore
    .find(Hotel.class)
    .inc("stars")
    .execute(new UpdateOptions()
        .multi(true));
----

=== Upserts

In some cases, updates are issued against a query that might not match any documents.  In these cases, it's often fine for those updates
to simply pass with no effect.  In other cases, it's desirable to create an initial document matching the query parameters.  Examples of
this might include user high scores, e.g. In cases like this, we have the option to use an upsert:

[source,java]
----
datastore
    .find(Hotel.class)
    .filter(gt("stars", 100))
    .update()
    .execute(new UpdateOptions()
                     .upsert(true));

// creates { "_id" : ObjectId("4c60629d2f1200000000161d"), "stars" : 50 }
----

=== Checking results

In all this one thing we haven't really looked at is how to verify the results of an update.  The `execute()` method returns an instance of
`com.mongodb.client.result.UpdateResult`.  Using this class, you can get specific numbers from the update operation as well as any
generated ID as the result of an upsert.

=== Returning the updated entity

There are times when a document needs to be updated and also fetched from the database.  In the server documentation, this is referred to
as {docsRef}/reference/method/db.collection.findAndModify/[`findAndModify`].  In Morphia, this functionality is exposed
through the {apiRef}/dev/morphia/query/Query#modify(dev.morphia.query.experimental.updates.UpdateOperator, dev.morphia.query.experimental.updates.UpdateOperator...)[Query#modify()]
method.  With this method, you can choose to return the updated entity in either the state before or after the update.  The default is
to return the entity in the _after_ state.  This can be changed by passing in a `ModifyOptions` reference to the operation:

[source,java]
----
datastore
    .find(Hotel.class)
    .modify(UpdateOperators.set("address.city", "Ottawa"))
    execute(new ModifyOptions()
        .returnDocument(ReturnDocument.BEFORE));
----

== Deletes

Queries are used to delete documents from the database as well.  Using {apiRef}/dev/morphia/query/Query#delete()[`Query#delete()`], we can
delete documents matching the query.  The default operation will only delete the first matching document.  However, you can opt to delete
all matches by passing in the appropriate options:

[source,java]
----
datastore
    .find(Hotel.class)
    .filter(gt("stars", 100))
    .delete(new DeleteOptions()
                     .multi(true));
----

